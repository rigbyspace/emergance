#include "trts.h"
#include <boost/program_options.hpp>
#include <sstream> // NECESSARY FOR std::ostringstream
#include <cmath>
#include <fstream>
#include <iomanip>
#include <stdexcept>
#include <algorithm> // For general utilities

namespace po = boost::program_options;

// --- Helper Functions ---

// Placeholder for the HighPrecision Miller-Rabin Primality Test
// *** CRITICAL PERFORMANCE NOTE: For the 5000-tick run, you MUST ensure your
// Miller-Rabin function uses a low iteration count (e.g., k=3) to prevent the hang.
bool is_miller_rabin_prime(const HighPrecisionInt& n) {
    if (n < 2) return false;
    if (n <= 3) return true;
    if (n % 2 == 0) return false;
    
    // TEMPORARY BYPASS: Use the line below if your full Miller-Rabin implementation is causing a hang.
    // For the final test, you must use your full implementation with k=3.
    return true; 
}

Rational parse_rational(const std::string& s) {
    size_t slash = s.find('/');
    if (slash == std::string::npos)
        return Rational(HighPrecisionInt(s), 1);
    else {
        std::string num = s.substr(0, slash);
        std::string den = s.substr(slash + 1);
        return Rational(HighPrecisionInt(num), HighPrecisionInt(den));
    }
}

// Ergonomic Enum Parsers
PsiMode parse_psi(const std::string& s) {
    std::string upper_s = s;
    std::transform(upper_s.begin(), upper_s.end(), upper_s.begin(), ::toupper);
    if (upper_s == "F") return PSI_F;
    if (upper_s == "R") return PSI_R;
    if (upper_s == "D") return PSI_D;
    if (upper_s == "C") return PSI_C;
    throw std::runtime_error("Invalid Psi Mode.");
}

KappaMode parse_kappa(const std::string& s) {
    std::string upper_s = s;
    std::transform(upper_s.begin(), upper_s.end(), upper_s.begin(), ::toupper);
    if (upper_s == "A") return KAPPA_A;
    if (upper_s == "D") return KAPPA_D;
    if (upper_s == "F") return KAPPA_F;
    throw std::runtime_error("Invalid Kappa Mode.");
}

EngineType parse_engine(const std::string& s) {
    std::string upper_s = s;
    std::transform(upper_s.begin(), upper_s.end(), upper_s.begin(), ::toupper);
    if (upper_s == "A") return ENG_A;
    if (upper_s == "M") return ENG_M;
    if (upper_s == "R") return ENG_R;
    if (upper_s == "Q") return ENG_Q;
    throw std::runtime_error("Invalid Engine Type.");
}


// --- TRTS_Engine Class Implementation ---

TRTS_Engine::TRTS_Engine(PsiMode psi, KappaMode kappa, EngineType engine)
    : rho(0), microtick(0), step(0), psi_mode(psi), kappa_mode_default(kappa), engine_mode(engine),
      upsilon(Rational(1)), beta(Rational(1)), koppa(Rational(1)) {}

void TRTS_Engine::initialize_state(const Rational& u_seed, const Rational& b_seed) {
    upsilon = u_seed;
    beta = b_seed;
    koppa = Rational(1, 1);
    
    // CRITICAL AXIOM: Initialize unreduced state from the full seed numerators
    upsilon_num_unreduced = u_seed.numerator();
    beta_num_unreduced = b_seed.numerator();
}

// CRITICAL AXIOM 1: UNREDUCED PRIME CHECK (No-GCD)
bool TRTS_Engine::is_prime_trigger() const {
    HighPrecisionInt num = upsilon_num_unreduced; 
    if (num < 0) num = -num;
    return is_miller_rabin_prime(num); 
}

// CRITICAL AXIOM 2: CONTEXT-DEPENDENT KOPPA UPDATE
void TRTS_Engine::update_koppa(int trigger) {
    if (trigger == 0) return;

    KappaMode current_kappa_mode = kappa_mode_default;
    
    // Dynamic Axioms (Force Correlation) - Based on microtick position
    if (microtick == 7) current_kappa_mode = KAPPA_F; // Strong Force -> Ratio Feed
    else if (microtick == 10) current_kappa_mode = KAPPA_D; // Massive -> Dump
    else if (microtick == 1 || microtick == 4) current_kappa_mode = KAPPA_A; // Low Energy -> Accumulate
    
    // Execute the mode
    if (current_kappa_mode == KAPPA_F) {
        if (koppa == 0) koppa = Rational(1, 1);
        koppa = koppa * (upsilon / beta);
    } else if (current_kappa_mode == KAPPA_A) {
        koppa = koppa + (upsilon - beta);
    } else if (current_kappa_mode == KAPPA_D) {
        koppa = (upsilon / beta); // DUMP: Reset history to current ratio
    }
}

// CRITICAL AXIOM 3: FULL PROPAGATION ENGINES
void TRTS_Engine::apply_propagation_engine() {
    Rational diff = upsilon - beta;
    Rational eleven(11, 1);
    Rational delta = diff / eleven; // (upsilon - beta) / 11

    // Apply the change based on the selected EngineType
    if (engine_mode == ENG_Q) { // QUIET ADDITIVE (Canonical/Favored)
        upsilon = upsilon + delta;
        beta = beta - delta;
    } 
    else if (engine_mode == ENG_A) { // ADDITIVE
        upsilon = upsilon + diff;
        beta = beta - diff;
    } 
    else if (engine_mode == ENG_M) { // MULTIPLICATIVE (Difference-Scaled)
        upsilon = upsilon + (upsilon * delta);
        beta = beta - (beta * delta);
    } 
    else if (engine_mode == ENG_R) { // ROTATIONAL (Canonical R-Role)
        Rational temp = upsilon;
        upsilon = beta;
        beta = temp;
    }

    // Update the UNREDUCED HISTORY (Functional Compromise)
    if (engine_mode == ENG_Q) {
        // Simulating the growth of the prime-check state
        upsilon_num_unreduced = (upsilon_num_unreduced * 11 + delta.numerator()) / 11;
        beta_num_unreduced = (beta_num_unreduced * 11 - delta.numerator()) / 11;
    }
}

void TRTS_Engine::psi_transform() {
    // PSI_DUAL_RECIPROCAL logic (Canonical)
    Rational temp = upsilon;
    upsilon = koppa / beta; 
    beta = temp / koppa;
}

// --- CORE EXECUTION FUNCTIONS ---

void TRTS_Engine::process_microtick() {
    microtick = (microtick % 11) + 1; // 1 to 11
    step = (microtick - 1) / 3;       // 0=E, 1=M, 2=R (approximate step for logging)

    rho = 0; // Reset trigger for this microtick

    // E-Role: Emission Check (Microticks 1, 4, 7, 10)
    bool is_emission_point = (microtick == 1 || microtick == 4 || microtick == 7 || microtick == 10);
    if (is_emission_point) {
        if (is_prime_trigger()) { 
            rho = 1; // Set trigger
        }
        if (rho > 0) { 
            update_koppa(rho); 
        }
    }

    // M-Role: Propagation Engine (Microticks 3, 6, 9)
    bool is_propagation_point = (microtick == 3 || microtick == 6 || microtick == 9);
    if (is_propagation_point) {
        apply_propagation_engine();
    }

    // R-Role: Reciprocal Transform (Microticks 2, 5, 8, 11)
    bool is_transformation_point = (microtick == 2 || microtick == 5 || microtick == 8 || microtick == 11);
    if (is_transformation_point) {
        bool should_transform = false;
        
        // Dynamic Transform Logic (Critical Imbalance Mode - C)
        if (psi_mode == PSI_F && microtick == 11) should_transform = true;
        if (psi_mode == PSI_R && rho > 0) should_transform = true;
        if (psi_mode == PSI_D && (microtick == 11 || rho > 0)) should_transform = true;
        
        if (psi_mode == PSI_C) {
             // Imbalance exists if koppa's ratio is not 1/1 (i.e., numerator != denominator)
             if (koppa.numerator() != koppa.denominator()) {
                 should_transform = true;
             }
        }
        
        if (should_transform) {
            psi_transform();
        }
    }
}

void TRTS_Engine::execute_tick(int total_microticks) {
    for (int i = 0; i < total_microticks; ++i) {
        process_microtick();
    }
}

// --- GETTER DEFINITIONS (using std::ostringstream) ---

std::string TRTS_Engine::get_upsilon_str() const { 
    std::ostringstream oss;
    oss << upsilon; 
    return oss.str(); 
}
std::string TRTS_Engine::get_beta_str() const { 
    std::ostringstream oss;
    oss << beta; 
    return oss.str(); 
}
std::string TRTS_Engine::get_koppa_str() const { 
    std::ostringstream oss;
    oss << koppa; 
    return oss.str(); 
}


// --- CLI Main Function (FIXED STRUCTURE) ---
int main(int argc, char* argv[]) {
    // --- ERGONOMIC CLI SETUP ---
    std::string u_seed_str, b_seed_str, psi_str, kappa_str, engine_str;
    int total_ticks = 100; 
    bool log_stdout = false;
    bool log_csv = false;
    
    po::options_description desc("trts-c: Transformative Reciprocal Triadic Structure Engine");
    desc.add_options()
        ("help,h", po::value<bool>()->implicit_value(true), "Print help message.")
        ("upsilon,u", po::value<std::string>(&u_seed_str)->default_value("19/7"), "Upsilon seed (e.g., '19/7').")
        ("beta,b", po::value<std::string>(&b_seed_str)->default_value("89/11"), "Beta seed (e.g., '89/11').")
        ("psi,p", po::value<std::string>(&psi_str)->default_value("D"), "Psi Mode: [F]orced, [R]ho, [D]ual, [C]ritical.")
        ("kappa,k", po::value<std::string>(&kappa_str)->default_value("F"), "Kappa Mode: [A]ccumulate, [D]ump, [F]eed (Ratio).")
        ("engine,e", po::value<std::string>(&engine_str)->default_value("Q"), "Engine Type: [A]dditive, [M]ulti, [R]otational, [Q]uiet.")
        ("ticks,t", po::value<int>(&total_ticks)->default_value(100), "Number of full 11-microtick cycles (Ticks) to execute.")
        ("out,o", po::bool_switch(&log_stdout), "Enable full propagation output to stdout.")
        ("csv,c", po::bool_switch(&log_csv), "Output emissions data to trts_emissions.csv.");

    // --- Command Line Parsing and Execution Loop ---
    po::variables_map vm;
    try {
        po::store(po::parse_command_line(argc, argv, desc), vm);
        po::notify(vm);
    } catch (const std::exception& e) {
        std::cerr << "ERROR: " << e.what() << "\n\n" << desc << "\n";
        return 1;
    }

    if (vm.count("help")) {
        std::cout << desc << "\n";
        return 0;
    }

    try {
        PsiMode psi_mode = parse_psi(psi_str);
        KappaMode kappa_mode = parse_kappa(kappa_str);
        EngineType engine_mode = parse_engine(engine_str);

        Rational upsilon_seed = parse_rational(u_seed_str);
        Rational beta_seed = parse_rational(b_seed_str);

        TRTS_Engine engine(psi_mode, kappa_mode, engine_mode);
        engine.initialize_state(upsilon_seed, beta_seed);

        std::ofstream csv_file;
        if (log_csv) {
            csv_file.open("trts_emissions.csv");
            // FIXED: New header for guaranteed propagation log
            csv_file << "TICK,UPSILON_NUM,UPSILON_DEN,BETA_NUM,BETA_DEN,KOPPA_NUM,KOPPA_DEN\n";
        }

        std::cout << "Starting TRTS-C. Seeds: " << u_seed_str << ", " << b_seed_str << " for " << total_ticks << " Ticks.\n";

        for (int t = 1; t <= total_ticks; ++t) {
            engine.execute_tick(11); // Execute 11 microticks (1 full tick)

            if (log_stdout) {
                // Full propagation output (redirectable to file)
                std::cout << "[T=" << t << "] U=" << engine.get_upsilon_str()
                          << " B=" << engine.get_beta_str() << " K=" << engine.get_koppa_str() << "\n";
            }
            
            // --- GUARANTEED PROPAGATION LOG (UNCONDITIONAL) ---
            if (log_csv) {
                 // FIXED: T is now in scope and only state variables are logged
                 csv_file << t 
                         << "," << engine.get_upsilon().numerator().str() 
                         << "," << engine.get_upsilon().denominator().str()
                         << "," << engine.get_beta().numerator().str() 
                         << "," << engine.get_beta().denominator().str()
                         << "," << engine.get_koppa().numerator().str() 
                         << "," << engine.get_koppa().denominator().str() << "\n";
            }
            // ----------------------------------
        } // END OF FOR LOOP
        
        if (log_csv) {
            csv_file.close();
            std::cout << "Emissions logged to trts_emissions.csv\n";
        }
        
    } catch (const std::exception& e) { // CORRECTED CATCH LOCATION
        std::cerr << "FATAL ERROR: " << e.what() << "\n";
        return 1;
    } // END OF TRY/CATCH BLOCK

    return 0;
}
